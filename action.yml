name: git-memento-note-comment
description: Post or update commit comments from git-memento notes (provider and session transcript).
author: git-memento contributors
branding:
  icon: message-square
  color: blue
inputs:
  github-token:
    description: GitHub token used to read/write commit comments.
    required: false
    default: ${{ github.token }}
  notes-fetch-refspec:
    description: Refspec used to fetch git notes.
    required: false
    default: refs/notes/*:refs/notes/*
  max-comment-length:
    description: Maximum comment body length to emit.
    required: false
    default: "65000"
runs:
  using: composite
  steps:
    - name: Fetch git notes
      shell: bash
      run: git fetch origin '${{ inputs.notes-fetch-refspec }}' || true

    - name: Install note renderer dependencies
      shell: bash
      run: npm --prefix "$GITHUB_ACTION_PATH" ci --omit=dev

    - name: Create or update commit comments from memento notes
      uses: actions/github-script@v7
      with:
        github-token: ${{ inputs.github-token }}
        script: |
          const { execSync } = require("child_process");
          const path = require("path");
          const renderer = require(path.join(process.env.GITHUB_ACTION_PATH || process.cwd(), "tools", "note-comment-renderer.js"));
          const { marker, buildBody, buildNoSessionBody } = renderer;
          const maxBodyLength = Number.parseInt(core.getInput("max-comment-length"), 10) || 65000;
          const { owner, repo } = context.repo;

          const isSha = (value) => /^[0-9a-f]{40}$/i.test(value || "");

          const getCommitShas = async () => {
            if (context.eventName === "push") {
              const before = context.payload.before;
              const after = context.payload.after;

              if (isSha(before) && isSha(after) && !/^0+$/.test(before)) {
                const output = execSync(`git rev-list ${before}..${after}`, { encoding: "utf8" }).trim();
                return output ? output.split("\n").filter(isSha) : [after];
              }

              return isSha(after) ? [after] : [];
            }

            if (context.eventName === "pull_request") {
              const prNumber = context.payload.pull_request.number;
              const commits = await github.paginate(github.rest.pulls.listCommits, {
                owner,
                repo,
                pull_number: prNumber,
                per_page: 100
              });

              return commits.map((c) => c.sha).filter(isSha);
            }

            return [];
          };

          const shas = [...new Set(await getCommitShas())];

          for (const sha of shas) {
            const existingComments = await github.paginate(github.rest.repos.listCommentsForCommit, {
              owner,
              repo,
              commit_sha: sha,
              per_page: 100
            });

            const existing = existingComments.find((c) => c.body && c.body.includes(marker));

            let note;
            try {
              note = execSync(`git notes show ${sha}`, { encoding: "utf8", stdio: ["ignore", "pipe", "ignore"] }).trim();
            } catch {
              core.info(`No git note found for ${sha}; posting fallback comment.`);
              note = "";
            }

            const body = note ? buildBody(note, maxBodyLength) : buildNoSessionBody();

            if (existing) {
              await github.rest.repos.updateCommitComment({
                owner,
                repo,
                comment_id: existing.id,
                body
              });
              core.info(`Updated memento note comment on commit ${sha}.`);
            } else {
              await github.rest.repos.createCommitComment({
                owner,
                repo,
                commit_sha: sha,
                body
              });
              core.info(`Created memento note comment on commit ${sha}.`);
            }
          }
