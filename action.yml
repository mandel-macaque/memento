name: git-memento-note-comment
description: Post or update commit comments from git-memento notes (provider and session transcript).
author: git-memento contributors
branding:
  icon: message-square
  color: blue
inputs:
  github-token:
    description: GitHub token used to read/write commit comments.
    required: false
    default: ${{ github.token }}
  notes-fetch-refspec:
    description: Refspec used to fetch git notes.
    required: false
    default: refs/notes/*:refs/notes/*
  max-comment-length:
    description: Maximum comment body length to emit.
    required: false
    default: "65000"
runs:
  using: composite
  steps:
    - name: Fetch git notes
      shell: bash
      run: git fetch origin '${{ inputs.notes-fetch-refspec }}' || true

    - name: Create or update commit comments from memento notes
      uses: actions/github-script@v7
      with:
        github-token: ${{ inputs.github-token }}
        script: |
          const { execSync } = require("child_process");

          const marker = "<!-- git-memento-note-comment -->";
          const maxBodyLength = Number.parseInt(core.getInput("max-comment-length"), 10) || 65000;
          const { owner, repo } = context.repo;

          const isSha = (value) => /^[0-9a-f]{40}$/i.test(value || "");

          const parseNote = (note) => {
            const providerMatch = note.match(/^- Provider:\s*(.+)$/m);
            const sessionIdMatch = note.match(/^- Session ID:\s*(.+)$/m);
            const provider = providerMatch ? providerMatch[1].trim() : "unknown";
            const sessionId = sessionIdMatch ? sessionIdMatch[1].trim() : "";
            return { provider, sessionId };
          };

          const buildBody = (note) => {
            const { provider, sessionId } = parseNote(note);
            const agentId = sessionId ? `${provider} / ${sessionId}` : provider;

            let body = `${marker}\nThis commit has a prompt attached to it created with agent ${agentId}:\n\n<details>\n<summary>The note attached to the commit</summary>\n\n${note}\n\n</details>`;

            if (body.length > maxBodyLength) {
              const reserve = "\n\n_Note truncated due to GitHub comment size limits._\n\n</details>";
              const head = `${marker}\nThis commit has a prompt attached to it created with agent ${agentId}:\n\n<details>\n<summary>The note attached to the commit</summary>\n\n`;
              const available = Math.max(0, maxBodyLength - head.length - reserve.length);
              body = `${head}${note.slice(0, available)}${reserve}`;
            }

            return body;
          };

          const getCommitShas = async () => {
            if (context.eventName === "push") {
              const before = context.payload.before;
              const after = context.payload.after;

              if (isSha(before) && isSha(after) && !/^0+$/.test(before)) {
                const output = execSync(`git rev-list ${before}..${after}`, { encoding: "utf8" }).trim();
                return output ? output.split("\n").filter(isSha) : [after];
              }

              return isSha(after) ? [after] : [];
            }

            if (context.eventName === "pull_request") {
              const prNumber = context.payload.pull_request.number;
              const commits = await github.paginate(github.rest.pulls.listCommits, {
                owner,
                repo,
                pull_number: prNumber,
                per_page: 100
              });

              return commits.map((c) => c.sha).filter(isSha);
            }

            return [];
          };

          const shas = [...new Set(await getCommitShas())];

          for (const sha of shas) {
            let note;
            try {
              note = execSync(`git notes show ${sha}`, { encoding: "utf8", stdio: ["ignore", "pipe", "ignore"] }).trim();
            } catch {
              core.info(`No git note found for ${sha}; skipping.`);
              continue;
            }

            if (!note) {
              core.info(`Git note for ${sha} is empty; skipping.`);
              continue;
            }

            const body = buildBody(note);

            const existingComments = await github.paginate(github.rest.repos.listCommentsForCommit, {
              owner,
              repo,
              commit_sha: sha,
              per_page: 100
            });

            const existing = existingComments.find((c) => c.body && c.body.includes(marker));

            if (existing) {
              await github.rest.repos.updateCommitComment({
                owner,
                repo,
                comment_id: existing.id,
                body
              });
              core.info(`Updated memento note comment on commit ${sha}.`);
            } else {
              await github.rest.repos.createCommitComment({
                owner,
                repo,
                commit_sha: sha,
                body
              });
              core.info(`Created memento note comment on commit ${sha}.`);
            }
          }
